<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/db_helper.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/db_helper.py" />
              <option name="originalContent" value="from dotenv import load_dotenv&#10;from typing import Dict&#10;import mysql.connector&#10;import os&#10;&#10;load_dotenv()&#10;DB_CONFIG = {&#10;    &quot;host&quot;: os.getenv(&quot;DB_HOST&quot;, &quot;localhost&quot;),&#10;    &quot;user&quot;: os.getenv(&quot;DB_USER&quot;, &quot;root&quot;),&#10;    &quot;password&quot;: os.getenv(&quot;DB_PASSWORD&quot;, &quot;&lt;PASSWORD&gt;&quot;),&#10;    &quot;database&quot;: os.getenv(&quot;DB_NAME&quot;, &quot;db&quot;),&#10;}&#10;&#10;def get_order_status(order_id: int) -&gt; str:&#10;    conn = mysql.connector.connect(**DB_CONFIG)&#10;    cursor = conn.cursor()&#10;    cursor.execute(&quot;SELECT status FROM order_tracking WHERE order_id = %s&quot;, (order_id,))&#10;    row = cursor.fetchone()&#10;    cursor.close()&#10;    conn.close()&#10;    return row[0] if row else None&#10;&#10;def save_to_db(order: Dict[str, int], session_id: str) -&gt; int:&#10;    &quot;&quot;&quot;&#10;    order: dict where key = food_name, value = quantity&#10;    session_id: para registro no header&#10;    Returns the generated order_header.id (order_id).&#10;    &quot;&quot;&quot;&#10;    conn = mysql.connector.connect(**DB_CONFIG)&#10;    cursor = conn.cursor()&#10;&#10;    # 1) Cria o header do pedido&#10;    cursor.execute(&#10;        &quot;INSERT INTO order_header (session_id) VALUES (%s)&quot;,&#10;        (session_id,)&#10;    )&#10;    header_id = cursor.lastrowid&#10;&#10;    # 2) Insere cada item (agora com header_id)&#10;    insert_item_sql = &quot;&quot;&quot;&#10;      INSERT INTO orders (header_id, food_id, quantity, total_price)&#10;      VALUES (%s, %s, %s, %s)&#10;    &quot;&quot;&quot;&#10;    for food_name, qty in order.items():&#10;        cursor.execute(&quot;SELECT id, price FROM food_items WHERE name = %s&quot;, (food_name,))&#10;        row = cursor.fetchone()&#10;        if not row:&#10;            continue&#10;        food_id, unit_price = row&#10;        total_price = float(unit_price) * qty&#10;&#10;        cursor.execute(insert_item_sql, (header_id, food_id, qty, total_price))&#10;&#10;    conn.commit()&#10;&#10;    # 3) Inicializa tracking usando o header_id&#10;    cursor.execute(&#10;        &quot;INSERT INTO order_tracking (order_id, status) VALUES (%s, %s)&quot;,&#10;        (header_id, &quot;Pending&quot;)&#10;    )&#10;    conn.commit()&#10;&#10;    cursor.close()&#10;    conn.close()&#10;&#10;    return header_id&#10;" />
              <option name="updatedContent" value="from dotenv import load_dotenv&#10;from typing import Dict&#10;import mysql.connector&#10;import os&#10;&#10;load_dotenv()&#10;DB_CONFIG = {&#10;    &quot;host&quot;: os.getenv(&quot;DB_HOST&quot;, &quot;localhost&quot;),&#10;    &quot;user&quot;: os.getenv(&quot;DB_USER&quot;, &quot;root&quot;),&#10;    &quot;password&quot;: os.getenv(&quot;DB_PASSWORD&quot;, &quot;&lt;PASSWORD&gt;&quot;),&#10;    &quot;database&quot;: os.getenv(&quot;DB_NAME&quot;, &quot;db&quot;),&#10;}&#10;&#10;def get_order_status(order_id: int) -&gt; str:&#10;    conn = mysql.connector.connect(**DB_CONFIG)&#10;    cursor = conn.cursor()&#10;    cursor.execute(&quot;SELECT status FROM order_tracking WHERE order_id = %s&quot;, (order_id,))&#10;    row = cursor.fetchone()&#10;    cursor.close()&#10;    conn.close()&#10;    return row[0] if row else None&#10;&#10;def save_to_db(order: Dict[str, int], session_id: str) -&gt; int:&#10;    &quot;&quot;&quot;&#10;    order: dict where key = food_name, value = quantity&#10;    session_id: para registro no header&#10;    Returns the generated order_header.id (order_id).&#10;    &quot;&quot;&quot;&#10;    conn = mysql.connector.connect(**DB_CONFIG)&#10;    cursor = conn.cursor()&#10;&#10;    # 1) Cria o header do pedido&#10;    cursor.execute(&#10;        &quot;INSERT INTO order_header (session_id) VALUES (%s)&quot;,&#10;        (session_id,)&#10;    )&#10;    header_id = cursor.lastrowid&#10;&#10;    # 2) Insere cada item (agora com header_id)&#10;    insert_item_sql = &quot;&quot;&quot;&#10;      INSERT INTO orders (header_id, food_id, quantity, total_price)&#10;      VALUES (%s, %s, %s, %s)&#10;    &quot;&quot;&quot;&#10;    for food_name, qty in order.items():&#10;        cursor.execute(&quot;SELECT id, price FROM food_items WHERE name = %s&quot;, (food_name,))&#10;        row = cursor.fetchone()&#10;        if not row:&#10;            continue&#10;        food_id, unit_price = row&#10;        total_price = float(unit_price) * qty&#10;&#10;        cursor.execute(insert_item_sql, (header_id, food_id, qty, total_price))&#10;&#10;    conn.commit()&#10;&#10;    # 3) Inicializa tracking usando o header_id&#10;    try:&#10;        cursor.execute(&#10;            &quot;INSERT INTO order_tracking (order_id, status) VALUES (%s, %s)&quot;,&#10;            (header_id, &quot;Pending&quot;)&#10;        )&#10;        conn.commit()&#10;    except mysql.connector.Error as err:&#10;        print(f&quot;Erro ao inserir tracking: {err}&quot;)&#10;&#10;    cursor.close()&#10;    conn.close()&#10;&#10;    return header_id" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/main.py" />
              <option name="originalContent" value="from fastapi import FastAPI, Request&#10;from typing import Any, Dict, List, Optional&#10;from pydantic import BaseModel&#10;from starlette.responses import JSONResponse&#10;from db_helper import get_order_status, save_to_db&#10;&#10;import uvicorn&#10;&#10;app = FastAPI()&#10;&#10;# ----- DTOs -----&#10;class Context(BaseModel):&#10;    name: str&#10;    lifespanCount: Optional[int] = None&#10;    parameters: Optional[Dict[str, Any]] = {}&#10;&#10;class QueryResult(BaseModel):&#10;    queryText: str&#10;    parameters: Dict[str, Any]&#10;    allRequiredParamsPresent: bool&#10;    outputContexts: Optional[List[Context]] = None&#10;    intent: Dict[str, Any]&#10;    intentDetectionConfidence: float&#10;&#10;class WebhookRequest(BaseModel):&#10;    responseId: str&#10;    session: str&#10;    queryResult: QueryResult&#10;    originalDetectIntentRequest: Optional[Dict[str, Any]] = None&#10;&#10;# ----- Helpers -----&#10;&#10;def extract_session_id(contexts: Optional[List[Context]]) -&gt; Optional[str]:&#10;    if not contexts:&#10;        return None&#10;    for ctx in contexts:&#10;        parts = ctx.name.split(&quot;/&quot;)&#10;        if &quot;sessions&quot; in parts:&#10;            idx = parts.index(&quot;sessions&quot;)&#10;            if idx + 1 &lt; len(parts):&#10;                return parts[idx + 1]&#10;    return None&#10;&#10;&#10;def make_ongoing_order_context(full_session_path: str, lifespan: int = 5) -&gt; Dict[str, Any]:&#10;    # full_session_path is wf_req.session, e.g. 'projects/.../sessions/{session_id}'&#10;    return {&#10;        &quot;name&quot;: f&quot;{full_session_path}/contexts/ongoing-order&quot;,&#10;        &quot;lifespanCount&quot;: lifespan,&#10;        &quot;parameters&quot;: {}&#10;    }&#10;&#10;inprogress_orders: Dict[str, Dict[str, int]] = {}&#10;&#10;# ----- Intent Handlers -----&#10;&#10;def handle_order_add(params: Dict[str, Any], session_path: str, session_id: str) -&gt; Dict[str, Any]:&#10;    raw_food = params.get(&quot;food&quot;) or params.get(&quot;food-item&quot;)&#10;    raw_qty  = params.get(&quot;quantity&quot;) or params.get(&quot;number&quot;)&#10;&#10;    items = raw_food if isinstance(raw_food, list) else ([raw_food] if raw_food else [])&#10;    qtys  = raw_qty  if isinstance(raw_qty, list)  else ([raw_qty]  if raw_qty  else [])&#10;&#10;    if not session_id:&#10;        return {&quot;fulfillmentText&quot;: &quot;Could not identify session. Please try again.&quot;}&#10;&#10;    if session_id not in inprogress_orders:&#10;        inprogress_orders[session_id] = {}&#10;    session_order = inprogress_orders[session_id]&#10;&#10;    parts = []&#10;    for i, item in enumerate(items):&#10;        q = int(qtys[i]) if i &lt; len(qtys) else 1&#10;        session_order[item] = session_order.get(item, 0) + q&#10;        parts.append(f&quot;{q} x {item}&quot;)&#10;&#10;    if parts:&#10;       fulfillment_text = f&quot;Added to your order ({session_id}): &quot; + &quot;, &quot;.join(parts)&#10;        return {&#10;            &quot;fulfillmentText&quot;: fulfillment_text,&#10;            &quot;outputContexts&quot;: [make_ongoing_order_context(session_path)]&#10;        }&#10;    else:&#10;        return {&quot;fulfillmentText&quot;: &quot;I didn't catch what you'd like to add. Can you repeat?&quot;}&#10;&#10;&#10;def handle_order_remove(params: Dict[str, Any], session_path: str, session_id: str) -&gt; Dict[str, Any]:&#10;    raw_food = params.get(&quot;food&quot;) or params.get(&quot;food-item&quot;)&#10;    items = raw_food if isinstance(raw_food, list) else ([raw_food] if raw_food else [])&#10;&#10;    if session_id in inprogress_orders:&#10;        session_order = inprogress_orders[session_id]&#10;        for item in items:&#10;            session_order.pop(item, None)&#10;&#10;    if items:&#10;        return {&quot;fulfillmentText&quot;: f&quot;Removed from your order ({session_id}): &quot; + &quot;, &quot;.join(items)}&#10;    else:&#10;        return {&quot;fulfillmentText&quot;: &quot;I didn't catch which item to remove. Please specify.&quot;}&#10;&#10;&#10;def complete_order(params: Dict[str, Any], session_path: str, session_id: str) -&gt; Dict[str, Any]:&#10;    if not session_id:&#10;        return {&quot;fulfillmentText&quot;: &quot;Could not identify session. Please try again.&quot;}&#10;    order = inprogress_orders.pop(session_id, {})&#10;    if not order:&#10;        return {&quot;fulfillmentText&quot;: &quot;Your order was empty. Nothing to complete.&quot;}&#10;&#10;    order_id = save_to_db(order)&#10;    return {&quot;fulfillmentText&quot;: (&#10;        f&quot;Your order has been placed! Your order ID is {order_id}. &quot;&#10;        &quot;You can track it anytime by telling me 'track order' and giving me that number.&quot;&#10;    )}&#10;&#10;&#10;def handle_track_order(params: Dict[str, Any], session_path: str, session_id: str) -&gt; Dict[str, Any]:&#10;    raw_number = params.get(&quot;number&quot;) or params.get(&quot;order_id&quot;)&#10;    order_id = raw_number[0] if isinstance(raw_number, list) and raw_number else raw_number&#10;    if not order_id:&#10;        return {&quot;fulfillmentText&quot;: &quot;I didn't catch your order ID. Could you please repeat it?&quot;}&#10;&#10;    status = get_order_status(int(order_id))&#10;    if status:&#10;        return {&quot;fulfillmentText&quot;: f&quot;Status for order {order_id}: {status}&quot;}&#10;    else:&#10;        return {&quot;fulfillmentText&quot;: f&quot;No tracking information found for order ID {order_id}.&quot;}&#10;&#10;# ----- Webhook Endpoint -----&#10;@app.post(&quot;/webhook&quot;)&#10;async def webhook(req: Request):&#10;    payload = await req.json()&#10;    wf_req = WebhookRequest(**payload)&#10;    intent_name = wf_req.queryResult.intent.get(&quot;displayName&quot;)&#10;    params = wf_req.queryResult.parameters&#10;    session_path = wf_req.session  # full path: projects/.../sessions/{session_id}&#10;    session_id = extract_session_id(wf_req.queryResult.outputContexts)&#10;    handlers = {&#10;        &quot;order.add - context: ongoing-order&quot;: handle_order_add,&#10;        &quot;order.remove - context: ongoing-order&quot;: handle_order_remove,&#10;        &quot;order.complete - context: ongoing-order&quot;: complete_order,&#10;        &quot;track.order - context: ongoing-tracking&quot;: handle_track_order&#10;    }&#10;    handler = handlers.get(intent_name, lambda p, sp, sid: {&quot;fulfillmentText&quot;: f&quot;Unknown intent {intent_name}.&quot;})&#10;    return JSONResponse(content=handler(params, session_path, session_id))&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    uvicorn.run(app, host=&quot;0.0.0.0&quot;, port=8000)&#10;" />
              <option name="updatedContent" value="from fastapi import FastAPI, Request&#10;from typing import Any, Dict, List, Optional&#10;from pydantic import BaseModel&#10;from starlette.responses import JSONResponse&#10;from db_helper import get_order_status, save_to_db&#10;&#10;import uvicorn&#10;&#10;app = FastAPI()&#10;&#10;# ----- DTOs -----&#10;class Context(BaseModel):&#10;    name: str&#10;    lifespanCount: Optional[int] = None&#10;    parameters: Optional[Dict[str, Any]] = {}&#10;&#10;class QueryResult(BaseModel):&#10;    queryText: str&#10;    parameters: Dict[str, Any]&#10;    allRequiredParamsPresent: bool&#10;    outputContexts: Optional[List[Context]] = None&#10;    intent: Dict[str, Any]&#10;    intentDetectionConfidence: float&#10;&#10;class WebhookRequest(BaseModel):&#10;    responseId: str&#10;    session: str&#10;    queryResult: QueryResult&#10;    originalDetectIntentRequest: Optional[Dict[str, Any]] = None&#10;&#10;# ----- Helpers -----&#10;&#10;def extract_session_id(contexts: Optional[List[Context]]) -&gt; Optional[str]:&#10;    if not contexts:&#10;        return None&#10;    for ctx in contexts:&#10;        parts = ctx.name.split(&quot;/&quot;)&#10;        if &quot;sessions&quot; in parts:&#10;            idx = parts.index(&quot;sessions&quot;)&#10;            if idx + 1 &lt; len(parts):&#10;                return parts[idx + 1]&#10;    return None&#10;&#10;&#10;def make_ongoing_order_context(full_session_path: str, lifespan: int = 5) -&gt; Dict[str, Any]:&#10;    # full_session_path is wf_req.session, e.g. 'projects/.../sessions/{session_id}'&#10;    return {&#10;        &quot;name&quot;: f&quot;{full_session_path}/contexts/ongoing-order&quot;,&#10;        &quot;lifespanCount&quot;: lifespan,&#10;        &quot;parameters&quot;: {}&#10;    }&#10;&#10;inprogress_orders: Dict[str, Dict[str, int]] = {}&#10;&#10;# ----- Intent Handlers -----&#10;&#10;def handle_order_add(params: Dict[str, Any], session_path: str, session_id: str) -&gt; Dict[str, Any]:&#10;    raw_food = params.get(&quot;food&quot;) or params.get(&quot;food-item&quot;)&#10;    raw_qty  = params.get(&quot;quantity&quot;) or params.get(&quot;number&quot;)&#10;&#10;    items = raw_food if isinstance(raw_food, list) else ([raw_food] if raw_food else [])&#10;    qtys  = raw_qty  if isinstance(raw_qty, list)  else ([raw_qty]  if raw_qty  else [])&#10;&#10;    if not session_id:&#10;        return {&quot;fulfillmentText&quot;: &quot;Could not identify session. Please try again.&quot;}&#10;&#10;    if session_id not in inprogress_orders:&#10;        inprogress_orders[session_id] = {}&#10;    session_order = inprogress_orders[session_id]&#10;&#10;    parts = []&#10;    for i, item in enumerate(items):&#10;        q = int(qtys[i]) if i &lt; len(qtys) else 1&#10;        session_order[item] = session_order.get(item, 0) + q&#10;        parts.append(f&quot;{q} x {item}&quot;)&#10;&#10;    if parts:&#10;        fulfillment_text = f&quot;Added to your order ({session_id}): &quot; + &quot;, &quot;.join(parts)&#10;        return {&#10;            &quot;fulfillmentText&quot;: fulfillment_text,&#10;            &quot;outputContexts&quot;: [make_ongoing_order_context(session_path)]&#10;        }&#10;    else:&#10;        return {&quot;fulfillmentText&quot;: &quot;I didn't catch what you'd like to add. Can you repeat?&quot;}&#10;&#10;&#10;def handle_order_remove(params: Dict[str, Any], session_path: str, session_id: str) -&gt; Dict[str, Any]:&#10;    raw_food = params.get(&quot;food&quot;) or params.get(&quot;food-item&quot;)&#10;    items = raw_food if isinstance(raw_food, list) else ([raw_food] if raw_food else [])&#10;&#10;    if session_id in inprogress_orders:&#10;        session_order = inprogress_orders[session_id]&#10;        for item in items:&#10;            session_order.pop(item, None)&#10;&#10;    if items:&#10;        return {&quot;fulfillmentText&quot;: f&quot;Removed from your order ({session_id}): &quot; + &quot;, &quot;.join(items)}&#10;    else:&#10;        return {&quot;fulfillmentText&quot;: &quot;I didn't catch which item to remove. Please specify.&quot;}&#10;&#10;&#10;def complete_order(params: Dict[str, Any], session_path: str, session_id: str) -&gt; Dict[str, Any]:&#10;    if not session_id:&#10;        return {&quot;fulfillmentText&quot;: &quot;Could not identify session. Please try again.&quot;}&#10;    order = inprogress_orders.pop(session_id, {})&#10;    if not order:&#10;        return {&quot;fulfillmentText&quot;: &quot;Your order was empty. Nothing to complete.&quot;}&#10;&#10;    order_id = save_to_db(order)&#10;    return {&quot;fulfillmentText&quot;: (&#10;        f&quot;Your order has been placed! Your order ID is {order_id}. &quot;&#10;        &quot;You can track it anytime by telling me 'track order' and giving me that number.&quot;&#10;    )}&#10;&#10;&#10;def handle_track_order(params: Dict[str, Any], session_path: str, session_id: str) -&gt; Dict[str, Any]:&#10;    raw_number = params.get(&quot;number&quot;) or params.get(&quot;order_id&quot;)&#10;    order_id = raw_number[0] if isinstance(raw_number, list) and raw_number else raw_number&#10;    if not order_id:&#10;        return {&quot;fulfillmentText&quot;: &quot;I didn't catch your order ID. Could you please repeat it?&quot;}&#10;&#10;    status = get_order_status(int(order_id))&#10;    if status:&#10;        return {&quot;fulfillmentText&quot;: f&quot;Status for order {order_id}: {status}&quot;}&#10;    else:&#10;        return {&quot;fulfillmentText&quot;: f&quot;No tracking information found for order ID {order_id}.&quot;}&#10;&#10;# ----- Webhook Endpoint -----&#10;@app.post(&quot;/webhook&quot;)&#10;async def webhook(req: Request):&#10;    payload = await req.json()&#10;    wf_req = WebhookRequest(**payload)&#10;    intent_name = wf_req.queryResult.intent.get(&quot;displayName&quot;)&#10;    params = wf_req.queryResult.parameters&#10;    session_path = wf_req.session  # full path: projects/.../sessions/{session_id}&#10;    session_id = extract_session_id(wf_req.queryResult.outputContexts)&#10;    handlers = {&#10;        &quot;order.add - context: ongoing-order&quot;: handle_order_add,&#10;        &quot;order.remove - context: ongoing-order&quot;: handle_order_remove,&#10;        &quot;order.complete - context: ongoing-order&quot;: complete_order,&#10;        &quot;track.order - context: ongoing-tracking&quot;: handle_track_order&#10;    }&#10;    handler = handlers.get(intent_name, lambda p, sp, sid: {&quot;fulfillmentText&quot;: f&quot;Unknown intent {intent_name}.&quot;})&#10;    return JSONResponse(content=handler(params, session_path, session_id))&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    uvicorn.run(app, host=&quot;0.0.0.0&quot;, port=8000)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>